LF term : type =
  | true         : term
  | false        : term
  | if_then_else : term → term → term → term
  | z            : term
  | succ         : term → term
  | pred         : term → term
  | iszero       : term → term
;

LF value : term → type =
  | v_true  : value true
  | v_false : value false
  | v_z     : value z
  | v_succ  : value V → value (succ V)
;

% Prove that [succ (succ z)] is a value by constructing a derivation for
% [succ (succ z) value]:
let example : [ ⊢ value (succ (succ z))] = [ ⊢ v_succ (v_succ (v_z))];

let example : [x:term, v:value x ⊢ value (succ (succ x))] =
              [x:term, v:value x ⊢ v_succ (v_succ v)];

% Examples:

let v1 = [ ⊢ if_then_else false z (succ z)];
let v2 = [ ⊢ iszero (pred (succ z))];

--not
let w1 = [ ⊢ iszero ];

--not
let w2 = [ ⊢ if_then_else z z];

% Small-step operational semantics.
LF step : term → term → type =
  % Congruence Rules
  | e_succ : step M N →
	   % ----------------------
	     step (succ M) (succ N)

  | e_pred : step M N →
	   % ----------------------
	     step (pred M) (pred N)

  | e_iszero : step M N →
	     % --------------------------
	       step (iszero M) (iszero N)

  | e_if_then_else : step M1 M1' →
		   % -----------------------------------------------------
		     step (if_then_else M1 M2 M3) (if_then_else M1' M2 M3)

  % Reduction Rules (Axioms)
  | e_if_true     : step (if_then_else true M2 M3) M2
  | e_if_false    : step (if_then_else false M2 M3) M3
  | e_pred_zero   : step (pred z) z
  | e_iszero_zero : step (iszero z) true

  | e_pred_succ : value V →
		% ----------------------
		  step (pred (succ V)) V

  | e_iszero_succ : value V →
		  % ----------------------------
		    step (iszero (succ V)) false
;

% Multi-step relation is the reflexive transitive closure
% over the single step relation.
LF multi_step : term → term → type =
  | ms_ref :
           % --------------
             multi_step M M

  | ms_tr : multi_step M N' → multi_step N' N →
          % -----------------------------------
            multi_step M N

  | ms_step : step M N →
            % --------------
              multi_step M N
;

let e1 : [ ⊢ step (pred (succ (pred z))) (pred (succ z))] =
         [ ⊢ e_pred (e_succ e_pred_zero)];

let e2 : [ ⊢ step (pred (succ z)) z] = [ ⊢ e_pred_succ v_z];

% Typing

LF tp : type =
  | nat  : tp
  | bool : tp
;

LF hastype : term → tp → type =
  | t_true  : hastype true bool
  | t_false : hastype false bool
  | t_zero  : hastype z nat

  | t_if : hastype M bool → hastype M1 T → hastype M2 T →
         % ----------------------------------------------
	   hastype (if_then_else M M1 M2) T

  | t_succ : hastype M nat →
	   % --------------------
	     hastype (succ M) nat

  | t_pred : hastype M nat →
	   % --------------------
	     hastype (pred M) nat

  | t_iszero : hastype M nat →
	     % -----------------------
	       hastype (iszero M) bool
;

% Type Preservation
% IF hastype M T AND step M N THEN hastype N T
%
% Programming point of view:
%  Given a typing derivation ⊢ M : T and a derivation for ⊢ M → N, return
%  a typing derivation ⊢ N : T.
%
% For an enconding in Beluga, note:
%  On paper  | Type in Beluga
%  ----------|------------------
%  ⊢ M : T   | [ ⊢ hastype M T ]
%  ⊢ M → N   | [ ⊢ step    M N ]
%

rec tps : [ ⊢ hastype M T] → [ ⊢ step M N] → [ ⊢ hastype N T] =
/ total s (tps _ _ _ _ s) /
fn d ⇒ fn s ⇒ case s of
  | [ ⊢ e_if_true]        ⇒ let [ ⊢ t_if D D1 D2] = d in [ ⊢ D1]
  | [ ⊢ e_if_false]       ⇒ let [ ⊢ t_if D D1 D2] = d in [ ⊢ D2]
  | [ ⊢ e_if_then_else S] ⇒ let [ ⊢ t_if D D1 D2] = d in
			    let [ ⊢ D'] = tps [ ⊢ D] [ ⊢ S] in
			    [ ⊢ t_if D' D1 D2]
  | [ ⊢ e_pred_zero]      ⇒ let [ ⊢ t_pred _] = d in [ ⊢ t_zero]
  | [ ⊢ e_pred_succ _]    ⇒ let [ ⊢ t_pred (t_succ D)] = d in [ ⊢ D]
  | [ ⊢ e_iszero_zero]    ⇒ let [ ⊢ t_iszero _] = d in [ ⊢ t_true]
  | [ ⊢ e_iszero_succ _]  ⇒ let [ ⊢ t_iszero _] = d in [ ⊢ t_false]
  | [ ⊢ e_pred S]         ⇒ let [ ⊢ t_pred D] = d in
			    let [ ⊢ D'] = tps [ ⊢ D] [ ⊢ S] in
			    [ ⊢ t_pred D']
  | [ ⊢ e_succ S]         ⇒ let [ ⊢ t_succ D] = d in
			    let [ ⊢ D'] = tps [ ⊢ D] [ ⊢ S] in
			    [ ⊢ t_succ D']
  | [ ⊢ e_iszero S]       ⇒ let [ ⊢ t_iszero D] = d in
			    let [ ⊢ D'] = tps [ ⊢ D] [ ⊢ S] in
			    [ ⊢ t_iszero D']
;

% Uniqueness of small-step evaluation
% A proof that evaluation using the small-step rules yields a unique value.
% IF step M M1 AND step M M2 THEN equal M1 M2.
%

% Define equality
LF equal : term → term → type = ref : equal M M;

% Define empty for falsehood
not_possible : type.

% Lemma
rec values_dont_step : [ ⊢ step M N] → [ ⊢ value M] → [ ⊢ not_possible] =
/ total val (values_dont_step _ _ _ val) /
fn step ⇒ fn val ⇒
  % On structural induction on the value.
  case val of
  % true and false are trivial as there are no constructors.
  | [ ⊢ v_false]  ⇒ impossible step
  | [ ⊢ v_true]   ⇒ impossible step
  % Here we want to argue that *every number* that is a value does not step.
  | [ ⊢ v_z]      ⇒ impossible step
  | [ ⊢ v_succ V] ⇒ let [ ⊢ e_succ D] = step in
		    values_dont_step [ ⊢ D] [ ⊢ V]
;

% Theorem
rec unique : [ ⊢ step M M1] → [ ⊢ step M M2] → [ ⊢ equal M1 M2] =
/ total s2 (unique M M1 M2 s1 s2) /
fn s1 ⇒ fn s2 ⇒
  case s1 of
    | [ ⊢ e_pred_zero] ⇒
	  (case s2 of
	    | [ ⊢ e_pred_zero] ⇒ [ ⊢ ref]
	    | [ ⊢ e_pred D] ⇒ impossible [ ⊢ D])

    | [ ⊢ e_succ D] ⇒
	  let [ ⊢ e_succ F] = s2 in
	  let [ ⊢ ref] = unique [ ⊢ D] [ ⊢ F] in
	  [ ⊢ ref]

    | [ ⊢ e_pred_succ V] ⇒
	  (case s2 of
	    | [ ⊢ e_pred_succ _] ⇒ [ ⊢ ref]
	    | [ ⊢ e_pred D] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_succ V]))

    | [ ⊢ e_pred D] ⇒
	  (case s2 of
	    | [ ⊢ e_pred F] ⇒
		  let [ ⊢ ref] = unique [ ⊢ D] [ ⊢ F] in [ ⊢ ref]
	    | [ ⊢ e_pred_zero] ⇒
		  impossible [ ⊢ D]
	    | [ ⊢ e_pred_succ V] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_succ V]))

    | [ ⊢ e_iszero D ] ⇒
	  (case s2 of
	    | [ ⊢ e_iszero F] ⇒
		  let [ ⊢ ref] = unique [ ⊢ D] [ ⊢ F] in [ ⊢ ref]
	    | [ ⊢ e_iszero_zero] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_z])
	    | [ ⊢ e_iszero_succ V] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_succ V]))

    | [ ⊢ e_iszero_zero] ⇒
	  (case s2 of
	    | [ ⊢ e_iszero F] ⇒
		  impossible (values_dont_step [ ⊢ F] [ ⊢ v_z])
	    | [ ⊢ e_iszero_zero] ⇒ [ ⊢ ref])

    | [ ⊢ e_iszero_succ V] ⇒
	  (case s2 of
	    | [ ⊢ e_iszero F] ⇒
		  impossible (values_dont_step [ ⊢ F] [ ⊢ v_succ V])
	    | [ ⊢ e_iszero_succ _] ⇒ [ ⊢ ref])

    | [ ⊢ e_if_false] ⇒
	  (case s2 of
	    | [ ⊢ e_if_false] ⇒ [ ⊢ ref]
	    | [ ⊢ e_if_then_else F] ⇒
		  impossible (values_dont_step [ ⊢ F] [ ⊢ v_false]))

    | [ ⊢ e_if_true] ⇒
	  (case s2 of
	    | [ ⊢ e_if_true] ⇒ [ ⊢ ref]
	    | [ ⊢ e_if_then_else F] ⇒
		  impossible (values_dont_step [ ⊢ F] [ ⊢ v_true]))

    | [ ⊢ e_if_then_else D] ⇒
	  (case s2 of
	    | [ ⊢ e_if_true] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_true])
	    | [ ⊢ e_if_false] ⇒
		  impossible (values_dont_step [ ⊢ D] [ ⊢ v_false])
	    | [ ⊢ e_if_then_else F] ⇒
		  let [ ⊢ ref] = unique [ ⊢ D] [ ⊢ F] in [ ⊢ ref])
;

% Terminaltion of well-typed terms.
% Want to prove that the evaluation of well-typed terms halts.

% Lemma: type preservation for multi-step.
rec multi_tps : [ ⊢ hastype M T] → [ ⊢ multi_step M M'] → [ ⊢ hastype M' T] =
/ total s (multi_tps m t m' d s) /
fn d ⇒ fn s ⇒ case s of
  | [ ⊢ ms_ref] ⇒ d
  | [ ⊢ ms_tr S1 S2] ⇒ let d1 = multi_tps d [ ⊢ S1] in
		       multi_tps d1 [ ⊢ S2]
  | [ ⊢ ms_step S] ⇒ tps d [ ⊢ S]
;

% Multi Step Lemmas:
%  1. IF M →* M' THEN (pred M) →* (pred M').
%  2. IF M →* M' THEN (succ M) →* (succ M').
%  3. IF M →* M' THEN (iszero M) →* (iszero M').
%  4. IF M →* M' THEN (if M then M1 else M2) →* (if M' then M1 else M2).

% Lemma (1):
% IF multi_step M M' THEN multi_step (pred M) (pred M').
rec mstep_pred : [ ⊢ multi_step M M'] → [ ⊢ multi_step (pred M) (pred M')] =
/ total ms (mstep_pred m m' ms) /
fn ms ⇒ case ms of
| [ ⊢ ms_ref] ⇒ [ ⊢ ms_ref]
| [ ⊢ ms_step S] ⇒ [ ⊢ ms_step (e_pred S)]
| [ ⊢ ms_tr MS1 MS2] ⇒
    let [ ⊢ MS1'] = mstep_pred [ ⊢ MS1] in
    let [ ⊢ MS2'] = mstep_pred [ ⊢ MS2] in
    [ ⊢ ms_tr MS1' MS2']
;

% Lemma (2):
% IF multi_step M M' THEN multi_step (succ M) (succ M').
rec mstep_succ : [ ⊢ multi_step M M'] → [ ⊢ multi_step (succ M) (succ M')] =
/ total ms (mstep_succ m m' ms) /
fn ms ⇒ case ms of
| [ ⊢ ms_ref] ⇒ [ ⊢ ms_ref]
| [ ⊢ ms_step S] ⇒ [ ⊢ ms_step (e_succ S)]
| [ ⊢ ms_tr MS1 MS2] ⇒
    let [ ⊢ MS1'] = mstep_succ [ ⊢ MS1] in
    let [ ⊢ MS2'] = mstep_succ [ ⊢ MS2] in
    [ ⊢ ms_tr MS1' MS2']
;

% Lemma (4):
% IF multi_step M M' THEN
%  multi_step (if_then_else M M2 M3) (if_then_else M' M2 M3).
rec mstep_if_then_else :
    [ ⊢ multi_step M M'] →
    {M2 : [ ⊢ term]} {M3 : [ ⊢ term]}
    [ ⊢ multi_step (if_then_else M M2 M3) (if_then_else M' M2 M3)] =
/ total ms (mstep_if_then_else _ _ ms) /
fn ms ⇒ case ms of
| [ ⊢ ms_ref ] ⇒ mlam M2 ⇒ mlam M3 ⇒ [ ⊢ ms_ref]
| [ ⊢ ms_step S] ⇒ mlam M2 ⇒ mlam M3 ⇒ [ ⊢ ms_step (e_if_then_else S)]
| [ ⊢ ms_tr S1 S2] ⇒
    mlam M2 ⇒ mlam M3 ⇒
    let [ ⊢ S1'] = mstep_if_then_else [ ⊢ S1] [ ⊢ M2] [ ⊢ M3] in
    let [ ⊢ S2'] = mstep_if_then_else [ ⊢ S2] [ ⊢ M2] [ ⊢ M3] in
    [ ⊢ ms_tr S1' S2']
;
